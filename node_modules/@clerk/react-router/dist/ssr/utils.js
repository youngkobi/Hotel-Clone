// src/ssr/utils.ts
import { constants, debugRequestState } from "@clerk/backend/internal";
import cookie from "cookie";
import { getPublicEnvVariables } from "../utils/env.js";
function isResponse(value) {
  return value != null && typeof value.status === "number" && typeof value.statusText === "string" && typeof value.headers === "object" && typeof value.body !== "undefined";
}
function isDataWithResponseInit(value) {
  return typeof value === "object" && value != null && "type" in value && "data" in value && "init" in value && value.type === "DataWithResponseInit";
}
function isRedirect(res) {
  return res.status >= 300 && res.status < 400;
}
var parseCookies = (req) => {
  return cookie.parse(req.headers.get("cookie") || "");
};
function assertValidHandlerResult(val, error) {
  if (val !== null && typeof val !== "object" || Array.isArray(val)) {
    throw new Error(error || "");
  }
}
var injectRequestStateIntoResponse = async (response, requestState, context) => {
  const clone = new Response(response.body, response);
  const data = await clone.json();
  const { clerkState, headers } = getResponseClerkState(requestState, context);
  clone.headers.set(constants.Headers.ContentType, constants.ContentTypes.Json);
  headers.forEach((value, key) => {
    clone.headers.append(key, value);
  });
  return Response.json({ ...data || {}, ...clerkState }, clone);
};
function getResponseClerkState(requestState, context) {
  const { reason, message, isSignedIn, ...rest } = requestState;
  const clerkState = wrapWithClerkState({
    __clerk_ssr_state: rest.toAuth(),
    __publishableKey: requestState.publishableKey,
    __proxyUrl: requestState.proxyUrl,
    __domain: requestState.domain,
    __isSatellite: requestState.isSatellite,
    __signInUrl: requestState.signInUrl,
    __signUpUrl: requestState.signUpUrl,
    __afterSignInUrl: requestState.afterSignInUrl,
    __afterSignUpUrl: requestState.afterSignUpUrl,
    __signInForceRedirectUrl: requestState.signInForceRedirectUrl,
    __signUpForceRedirectUrl: requestState.signUpForceRedirectUrl,
    __signInFallbackRedirectUrl: requestState.signInFallbackRedirectUrl,
    __signUpFallbackRedirectUrl: requestState.signUpFallbackRedirectUrl,
    __clerk_debug: debugRequestState(requestState),
    __clerkJSUrl: getPublicEnvVariables(context).clerkJsUrl,
    __clerkJSVersion: getPublicEnvVariables(context).clerkJsVersion,
    __telemetryDisabled: getPublicEnvVariables(context).telemetryDisabled,
    __telemetryDebug: getPublicEnvVariables(context).telemetryDebug
  });
  return {
    clerkState,
    headers: requestState.headers
  };
}
var wrapWithClerkState = (data) => {
  return { clerkState: { __internal_clerk_state: { ...data } } };
};
var patchRequest = (request) => {
  const clonedRequest = new Request(request.url, {
    headers: request.headers,
    method: request.method,
    redirect: request.redirect,
    cache: request.cache,
    signal: request.signal
  });
  if (clonedRequest.method !== "GET" && clonedRequest.body !== null && !("duplex" in clonedRequest)) {
    clonedRequest.duplex = "half";
  }
  return clonedRequest;
};
export {
  assertValidHandlerResult,
  getResponseClerkState,
  injectRequestStateIntoResponse,
  isDataWithResponseInit,
  isRedirect,
  isResponse,
  parseCookies,
  patchRequest,
  wrapWithClerkState
};
//# sourceMappingURL=utils.js.map