{"version":3,"sources":["../../src/ssr/getAuth.ts"],"sourcesContent":["import {\n  type AuthenticateRequestOptions,\n  type GetAuthFn,\n  getAuthObjectForAcceptedToken,\n} from '@clerk/backend/internal';\nimport type { LoaderFunctionArgs } from 'react-router';\n\nimport { noLoaderArgsPassedInGetAuth } from '../utils/errors';\nimport { authenticateRequest } from './authenticateRequest';\nimport { loadOptions } from './loadOptions';\nimport type { RootAuthLoaderOptions } from './types';\n\ntype GetAuthOptions = { acceptsToken?: AuthenticateRequestOptions['acceptsToken'] } & Pick<\n  RootAuthLoaderOptions,\n  'secretKey'\n>;\n\nexport const getAuth: GetAuthFn<LoaderFunctionArgs, true> = (async (\n  args: LoaderFunctionArgs,\n  opts?: GetAuthOptions,\n) => {\n  if (!args || (args && (!args.request || !args.context))) {\n    throw new Error(noLoaderArgsPassedInGetAuth);\n  }\n\n  const { acceptsToken, ...restOptions } = opts || {};\n\n  const loadedOptions = loadOptions(args, restOptions);\n  // Note: authenticateRequest() will throw a redirect if the auth state is determined to be handshake\n  const requestState = await authenticateRequest(args, {\n    ...loadedOptions,\n    acceptsToken: 'any',\n  });\n\n  const authObject = requestState.toAuth();\n\n  return getAuthObjectForAcceptedToken({ authObject, acceptsToken });\n}) as GetAuthFn<LoaderFunctionArgs, true>;\n"],"mappings":";AAAA;AAAA,EAGE;AAAA,OACK;AAGP,SAAS,mCAAmC;AAC5C,SAAS,2BAA2B;AACpC,SAAS,mBAAmB;AAQrB,IAAM,UAAgD,OAC3D,MACA,SACG;AACH,MAAI,CAAC,QAAS,SAAS,CAAC,KAAK,WAAW,CAAC,KAAK,UAAW;AACvD,UAAM,IAAI,MAAM,2BAA2B;AAAA,EAC7C;AAEA,QAAM,EAAE,cAAc,GAAG,YAAY,IAAI,QAAQ,CAAC;AAElD,QAAM,gBAAgB,YAAY,MAAM,WAAW;AAEnD,QAAM,eAAe,MAAM,oBAAoB,MAAM;AAAA,IACnD,GAAG;AAAA,IACH,cAAc;AAAA,EAChB,CAAC;AAED,QAAM,aAAa,aAAa,OAAO;AAEvC,SAAO,8BAA8B,EAAE,YAAY,aAAa,CAAC;AACnE;","names":[]}