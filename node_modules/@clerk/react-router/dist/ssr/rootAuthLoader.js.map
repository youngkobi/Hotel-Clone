{"version":3,"sources":["../../src/ssr/rootAuthLoader.ts"],"sourcesContent":["import { decorateObjectWithResources } from '@clerk/backend/internal';\nimport type { LoaderFunctionArgs } from 'react-router';\n\nimport { invalidRootLoaderCallbackReturn } from '../utils/errors';\nimport { authenticateRequest } from './authenticateRequest';\nimport { loadOptions } from './loadOptions';\nimport type { LoaderFunctionReturn, RootAuthLoaderCallback, RootAuthLoaderOptions } from './types';\nimport {\n  assertValidHandlerResult,\n  injectRequestStateIntoResponse,\n  isDataWithResponseInit,\n  isRedirect,\n  isResponse,\n} from './utils';\n\ninterface RootAuthLoader {\n  <Options extends RootAuthLoaderOptions, Callback extends RootAuthLoaderCallback<Options>>(\n    /**\n     * Arguments passed to the loader function.\n     */\n    args: LoaderFunctionArgs,\n    /**\n     * A loader function with authentication state made available to it. Allows you to fetch route data based on the user's authentication state.\n     */\n    callback: Callback,\n    options?: Options,\n  ): Promise<ReturnType<Callback>>;\n\n  (args: LoaderFunctionArgs, options?: RootAuthLoaderOptions): Promise<LoaderFunctionReturn>;\n}\n\n/**\n * Makes authorization state available in your application by wrapping the root loader.\n *\n * @see https://clerk.com/docs/quickstarts/react-router\n */\nexport const rootAuthLoader: RootAuthLoader = async (\n  args: LoaderFunctionArgs,\n  handlerOrOptions: any,\n  options?: any,\n): Promise<LoaderFunctionReturn> => {\n  const handler = typeof handlerOrOptions === 'function' ? handlerOrOptions : undefined;\n  const opts: RootAuthLoaderOptions = options\n    ? options\n    : !!handlerOrOptions && typeof handlerOrOptions !== 'function'\n      ? handlerOrOptions\n      : {};\n\n  const loadedOptions = loadOptions(args, opts);\n  // Note: authenticateRequest() will throw a redirect if the auth state is determined to be handshake\n  const _requestState = await authenticateRequest(args, loadedOptions);\n  // TODO: Investigate if `authenticateRequest` needs to return the loadedOptions (the new request urls in particular)\n  const requestState = { ...loadedOptions, ..._requestState };\n\n  if (!handler) {\n    // if the user did not provide a handler, simply inject requestState into an empty response\n    return injectRequestStateIntoResponse(new Response(JSON.stringify({})), requestState, args.context);\n  }\n\n  const authObj = requestState.toAuth();\n  const requestWithAuth = Object.assign(args.request, { auth: authObj });\n  await decorateObjectWithResources(requestWithAuth, authObj, loadedOptions);\n  const handlerResult = await handler(args);\n  assertValidHandlerResult(handlerResult, invalidRootLoaderCallbackReturn);\n\n  if (isResponse(handlerResult)) {\n    try {\n      // respect and pass-through any redirects without modifying them\n      if (isRedirect(handlerResult)) {\n        return handlerResult;\n      }\n      // clone and try to inject requestState into all json-like responses\n      // if this fails, the user probably didn't return a json object or a valid json string\n      return injectRequestStateIntoResponse(handlerResult, requestState, args.context);\n    } catch {\n      throw new Error(invalidRootLoaderCallbackReturn);\n    }\n  }\n\n  if (isDataWithResponseInit(handlerResult)) {\n    try {\n      // clone and try to inject requestState into all json-like responses\n      // if this fails, the user probably didn't return a json object or a valid json string\n      return injectRequestStateIntoResponse(\n        new Response(JSON.stringify(handlerResult.data), handlerResult.init ?? undefined),\n        requestState,\n        args.context,\n      );\n    } catch {\n      throw new Error(invalidRootLoaderCallbackReturn);\n    }\n  }\n\n  // if the return value of the user's handler is null or a plain object, create an empty response to inject Clerk's state into\n  const responseBody = JSON.stringify(handlerResult ?? {});\n\n  return injectRequestStateIntoResponse(new Response(responseBody), requestState, args.context);\n};\n"],"mappings":";AAAA,SAAS,mCAAmC;AAG5C,SAAS,uCAAuC;AAChD,SAAS,2BAA2B;AACpC,SAAS,mBAAmB;AAE5B;AAAA,EACE;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,OACK;AAuBA,IAAM,iBAAiC,OAC5C,MACA,kBACA,YACkC;AAxCpC;AAyCE,QAAM,UAAU,OAAO,qBAAqB,aAAa,mBAAmB;AAC5E,QAAM,OAA8B,UAChC,UACA,CAAC,CAAC,oBAAoB,OAAO,qBAAqB,aAChD,mBACA,CAAC;AAEP,QAAM,gBAAgB,YAAY,MAAM,IAAI;AAE5C,QAAM,gBAAgB,MAAM,oBAAoB,MAAM,aAAa;AAEnE,QAAM,eAAe,EAAE,GAAG,eAAe,GAAG,cAAc;AAE1D,MAAI,CAAC,SAAS;AAEZ,WAAO,+BAA+B,IAAI,SAAS,KAAK,UAAU,CAAC,CAAC,CAAC,GAAG,cAAc,KAAK,OAAO;AAAA,EACpG;AAEA,QAAM,UAAU,aAAa,OAAO;AACpC,QAAM,kBAAkB,OAAO,OAAO,KAAK,SAAS,EAAE,MAAM,QAAQ,CAAC;AACrE,QAAM,4BAA4B,iBAAiB,SAAS,aAAa;AACzE,QAAM,gBAAgB,MAAM,QAAQ,IAAI;AACxC,2BAAyB,eAAe,+BAA+B;AAEvE,MAAI,WAAW,aAAa,GAAG;AAC7B,QAAI;AAEF,UAAI,WAAW,aAAa,GAAG;AAC7B,eAAO;AAAA,MACT;AAGA,aAAO,+BAA+B,eAAe,cAAc,KAAK,OAAO;AAAA,IACjF,QAAQ;AACN,YAAM,IAAI,MAAM,+BAA+B;AAAA,IACjD;AAAA,EACF;AAEA,MAAI,uBAAuB,aAAa,GAAG;AACzC,QAAI;AAGF,aAAO;AAAA,QACL,IAAI,SAAS,KAAK,UAAU,cAAc,IAAI,IAAG,mBAAc,SAAd,YAAsB,MAAS;AAAA,QAChF;AAAA,QACA,KAAK;AAAA,MACP;AAAA,IACF,QAAQ;AACN,YAAM,IAAI,MAAM,+BAA+B;AAAA,IACjD;AAAA,EACF;AAGA,QAAM,eAAe,KAAK,UAAU,wCAAiB,CAAC,CAAC;AAEvD,SAAO,+BAA+B,IAAI,SAAS,YAAY,GAAG,cAAc,KAAK,OAAO;AAC9F;","names":[]}