// src/client/ReactRouterClerkProvider.tsx
import { ClerkProvider as ReactClerkProvider } from "@clerk/clerk-react";
import React from "react";
import {
  assertPublishableKeyInSpaMode,
  assertValidClerkState,
  isSpaMode as _isSpaMode,
  warnForSsr
} from "../utils/assert.js";
import { ClerkReactRouterOptionsProvider } from "./ReactRouterOptionsContext.js";
import { useAwaitableNavigate } from "./useAwaitableNavigate.js";
export * from "@clerk/clerk-react";
var SDK_METADATA = {
  name: "@clerk/react-router",
  version: "1.8.12"
};
var awaitableNavigateRef = { current: void 0 };
function ClerkProviderBase({ children, ...rest }) {
  const awaitableNavigate = useAwaitableNavigate();
  const isSpaMode = _isSpaMode();
  React.useEffect(() => {
    awaitableNavigateRef.current = awaitableNavigate;
  }, [awaitableNavigate]);
  const { clerkState, ...restProps } = rest;
  ReactClerkProvider.displayName = "ReactClerkProvider";
  if (typeof isSpaMode !== "undefined" && !isSpaMode) {
    assertValidClerkState(clerkState);
  }
  const {
    __clerk_ssr_state,
    __publishableKey,
    __proxyUrl,
    __domain,
    __isSatellite,
    __clerk_debug,
    __signInUrl,
    __signUpUrl,
    __afterSignInUrl,
    __afterSignUpUrl,
    __signInForceRedirectUrl,
    __signUpForceRedirectUrl,
    __signInFallbackRedirectUrl,
    __signUpFallbackRedirectUrl,
    __clerkJSUrl,
    __clerkJSVersion,
    __telemetryDisabled,
    __telemetryDebug
  } = (clerkState == null ? void 0 : clerkState.__internal_clerk_state) || {};
  React.useEffect(() => {
    if (typeof isSpaMode !== "undefined" && !isSpaMode) {
      warnForSsr(clerkState);
    }
  }, []);
  React.useEffect(() => {
    window.__clerk_debug = __clerk_debug;
  }, []);
  const mergedProps = {
    publishableKey: __publishableKey,
    proxyUrl: __proxyUrl,
    domain: __domain,
    isSatellite: __isSatellite,
    signInUrl: __signInUrl,
    signUpUrl: __signUpUrl,
    afterSignInUrl: __afterSignInUrl,
    afterSignUpUrl: __afterSignUpUrl,
    signInForceRedirectUrl: __signInForceRedirectUrl,
    signUpForceRedirectUrl: __signUpForceRedirectUrl,
    signInFallbackRedirectUrl: __signInFallbackRedirectUrl,
    signUpFallbackRedirectUrl: __signUpFallbackRedirectUrl,
    clerkJSUrl: __clerkJSUrl,
    clerkJSVersion: __clerkJSVersion,
    telemetry: {
      disabled: __telemetryDisabled,
      debug: __telemetryDebug
    }
  };
  return /* @__PURE__ */ React.createElement(ClerkReactRouterOptionsProvider, { options: mergedProps }, /* @__PURE__ */ React.createElement(
    ReactClerkProvider,
    {
      routerPush: (to) => {
        var _a;
        return (_a = awaitableNavigateRef.current) == null ? void 0 : _a.call(awaitableNavigateRef, to);
      },
      routerReplace: (to) => {
        var _a;
        return (_a = awaitableNavigateRef.current) == null ? void 0 : _a.call(awaitableNavigateRef, to, { replace: true });
      },
      initialState: __clerk_ssr_state,
      sdkMetadata: SDK_METADATA,
      ...mergedProps,
      ...restProps
    },
    children
  ));
}
var ClerkProvider = ({ children, loaderData, ...opts }) => {
  let clerkState;
  const isSpaMode = _isSpaMode();
  if (!isSpaMode && (loaderData == null ? void 0 : loaderData.clerkState)) {
    clerkState = loaderData.clerkState;
  }
  if (typeof isSpaMode !== "undefined" && isSpaMode) {
    assertPublishableKeyInSpaMode(opts.publishableKey);
  }
  return /* @__PURE__ */ React.createElement(
    ClerkProviderBase,
    {
      ...opts,
      clerkState
    },
    children
  );
};
export {
  ClerkProvider
};
//# sourceMappingURL=ReactRouterClerkProvider.js.map